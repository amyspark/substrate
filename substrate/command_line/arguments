// SPDX-License-Identifier: BSD-3-Clause
#ifndef SUBSTRATE_COMMAND_LINE_ARGUMENTS
#define SUBSTRATE_COMMAND_LINE_ARGUMENTS

#include <cstddef>
#include <optional>
#include <vector>
#include <set>
#include <variant>
#include <any>
#include <substrate/command_line/options>

namespace substrate::commandLine
{
	namespace internal
	{
		struct tokeniser_t;
	}

	struct choice_t;

	struct flag_t
	{
	private:
		std::string_view _name;
		std::any _value{};

	public:
		flag_t(const std::string_view &name) noexcept : _name{name} { }
		flag_t(const std::string_view &name, std::any &&value) noexcept : _name{name}, _value{std::move(value)} { }

		[[nodiscard]] auto &name() const noexcept { return _name; }
		[[nodiscard]] auto &value() const noexcept { return _value; }
	};

	using item_t = std::variant<flag_t, choice_t>;

	struct SUBSTRATE_CLS_API arguments_t
	{
	private:
		using vector_t = std::vector<item_t>;
		using iterator_t = typename vector_t::const_iterator;
		using optionsVisited_t = std::set<internal::optionsItem_t>;

		vector_t _arguments;

		[[nodiscard]] std::optional<bool> parseArgument(internal::tokeniser_t &lexer, const options_t &options,
			optionsVisited_t &optionsVisited);

	public:
		arguments_t() noexcept;

		[[nodiscard]] bool parseFrom(internal::tokeniser_t &lexer, const options_t &options);
		[[nodiscard]] bool add(item_t argument) noexcept;

		[[nodiscard]] size_t count() const noexcept;
		[[nodiscard]] iterator_t begin() const noexcept;
		[[nodiscard]] iterator_t end() const noexcept;
		[[nodiscard]] iterator_t find(const std::string_view &option) const noexcept;
		[[nodiscard]] const item_t &operator [](size_t index) const noexcept;
		[[nodiscard]] const item_t *operator [](const std::string_view &option) const noexcept;
	};

	struct choice_t
	{
	private:
		std::string_view _name;
		std::string_view _value;
		arguments_t _arguments;

	public:
		choice_t(const std::string_view &name, const std::string_view &value, arguments_t &&arguments) noexcept :
			_name{name}, _value{value}, _arguments{std::move(arguments)} { }

		[[nodiscard]] auto &name() const noexcept { return _name; }
		[[nodiscard]] auto &value() const noexcept { return _value; }
		[[nodiscard]] auto &arguments() const noexcept { return _arguments; }
	};

	SUBSTRATE_API std::optional<arguments_t>
		parseArguments(size_t argCount, const char *const *argList, const options_t &options);

	std::optional<arguments_t>
		parseArguments(size_t argCount, const char *const *argList, const internal::optionsHolder_t &options)
	{
		const options_t programOptions{options};
		return parseArguments(argCount, argList, programOptions);
	}
} // namespace substrate::commandLine

#endif /* SUBSTRATE_COMMAND_LINE_ARGUMENTS */
/* vim: set ft=cpp ts=4 sw=4 noexpandtab: */
