// SPDX-License-Identifier: BSD-3-Clause
#ifndef SUBSTRATE_COMMAND_LINE_OPTIONS
#define SUBSTRATE_COMMAND_LINE_OPTIONS

#include <cstddef>
#include <cassert>
#include <vector>
#include <variant>
#include <any>
#include <tuple>
#include <optional>
#include <string_view>
#include <functional>
#include <type_traits>
#include <substrate/static_vector>
#include <substrate/index_sequence>
#include <substrate/flags>
#include <substrate/utility>

namespace substrate::commandLine
{
	enum class optionFlags_t
	{
		repeatable,
		takesParameter
	};

	enum class optionValueType_t
	{
		signedInt,
		unsignedInt,
		boolean,
		string,
		path,
		userDefined,
	};

	struct optionFlagPair_t final
	{
		std::string_view _shortFlag{};
		std::string_view _longFlag{};
	};

	struct optionValue_t final { };
	struct optionAlternation_t;

	struct optionSignedInt_t final
	{
		int64_t min{INT64_MIN};
		int64_t max{INT64_MAX};
	};

	struct optionUnsignedInt_t final
	{
		uint64_t min{0U};
		uint64_t max{UINT64_MAX};
	};

	using optionValueParser_t = std::optional<std::any> (*)(const std::string_view &) noexcept;

	// A singular command line option such as a simple flag
	struct SUBSTRATE_CLS_API option_t final
	{
	private:
		using optionHolder_t = std::variant<std::string_view, optionFlagPair_t, std::monostate>;
		using flagsHolder_t = bitFlags_t<uint8_t, optionFlags_t>;

		optionHolder_t _option;
		std::string_view _help;
		flagsHolder_t _flags{};
		optionValueType_t _valueType{optionValueType_t::string};
		std::variant<std::monostate, optionSignedInt_t, optionUnsignedInt_t> _valueAllowedRange{};
		optionValueParser_t _valueParserFn{nullptr};

	public:
		constexpr option_t(const optionHolder_t &option, const std::string_view &help) noexcept :
			_option{option}, _help{help} { }
		constexpr option_t(const optionValue_t &, const std::string_view &help) noexcept :
			_option{std::monostate{}}, _help{help}, _flags{optionFlags_t::takesParameter} { }
		constexpr option_t(const option_t &) noexcept = default;
		constexpr option_t(option_t &&) noexcept = default;

		constexpr option_t &operator =(const option_t &) noexcept = default;
		constexpr option_t &operator =(option_t &&) noexcept = default;

		[[nodiscard]] constexpr option_t &valueType(const optionValueType_t type = optionValueType_t::string,
			const optionValueParser_t valueParserFn = nullptr) noexcept
		{
			_valueType = type;
			if (type == optionValueType_t::userDefined)
			{
				// A user-defined option must supply a parsing function to use
				assert(valueParserFn != nullptr);
				_valueParserFn = valueParserFn;
			}
			return *this;
		}

		[[nodiscard]] constexpr option_t &takesParameter(const optionValueType_t type = optionValueType_t::string,
			const optionValueParser_t valueParserFn = nullptr) noexcept
		{
			_flags.set(optionFlags_t::takesParameter);
			return valueType(type, valueParserFn);
		}

		[[nodiscard]] constexpr option_t &repeatable() noexcept
		{
			_flags.set(optionFlags_t::repeatable);
			return *this;
		}

		template<typename T> [[nodiscard]] constexpr option_t &valueRange(T min, T max) noexcept
		{
			if (_valueType == optionValueType_t::signedInt)
				_valueAllowedRange = optionSignedInt_t{min, max};
			else if (_valueType == optionValueType_t::unsignedInt)
				_valueAllowedRange = optionUnsignedInt_t{min, max};
			return *this;
		}

		[[nodiscard]] bool matches(const std::string_view &argument) const noexcept;
		[[nodiscard]] std::optional<std::any> parseValue(const std::string_view &value) const noexcept;

		[[nodiscard]] constexpr bool takesParameter() const noexcept
			{ return _flags.includes(optionFlags_t::takesParameter); }
		[[nodiscard]] constexpr bool isRepeatable() const noexcept
			{ return _flags.includes(optionFlags_t::repeatable); }
		[[nodiscard]] constexpr bool valueOnly() const noexcept
			{ return std::holds_alternative<std::monostate>(_option); }

		[[nodiscard]] constexpr auto &helpText() const noexcept { return _help; }

	private:
		[[nodiscard]] std::optional<std::any> parseSignedValue(const std::string_view &value) const noexcept;
		[[nodiscard]] std::optional<std::any> parseUnsignedValue(const std::string_view &value) const noexcept;
		[[nodiscard]] static std::optional<std::any> parseBoolValue(const std::string_view &value) noexcept;
		[[nodiscard]] static std::optional<std::any> parsePathValue(const std::string_view &value) noexcept;
	};

	// A set of command line option alternations such as a set of commands
	struct SUBSTRATE_CLS_API optionSet_t final
	{
	private:
		staticVector_t<const optionAlternation_t> _alternations;

	public:
		constexpr optionSet_t(const staticVector_t<const optionAlternation_t> &alternations) :
			_alternations{alternations} { }
		constexpr optionSet_t(const optionSet_t &) noexcept = default;
		constexpr optionSet_t(optionSet_t &&) noexcept = default;

		constexpr optionSet_t &operator =(const optionSet_t &) noexcept = default;
		constexpr optionSet_t &operator =(optionSet_t &&) noexcept = default;

		[[nodiscard]] std::optional<std::reference_wrapper<const optionAlternation_t>>
			matches(const std::string_view &argument) const noexcept;
	};

	template<size_t N> constexpr static inline auto
		optionAlternations(optionAlternation_t (&&alternations)[N]) noexcept
			{ return make_array<const optionAlternation_t>(std::move(alternations)); }

	namespace internal
	{
		using optionsItem_t = std::variant<option_t, optionSet_t>;
	}

	// The base container for a program's command line options
	struct options_t final
	{
	private:
		staticVector_t<const internal::optionsItem_t> _options{};

	public:
		constexpr options_t() noexcept = default;
		constexpr options_t(staticVector_t<const internal::optionsItem_t> &&options) :
			_options{std::move(options)} { }
		constexpr options_t(const options_t &) noexcept = default;
		constexpr options_t(options_t &&) noexcept = default;

		constexpr options_t &operator =(const options_t &) noexcept = default;
		constexpr options_t &operator =(options_t &&) noexcept = default;

		[[nodiscard]] constexpr auto empty() const noexcept { return _options.empty(); }
		[[nodiscard]] constexpr auto begin() const noexcept { return _options.begin(); }
		[[nodiscard]] constexpr auto end() const noexcept { return _options.end(); }
	};

	namespace internal
	{
		using substrate::internal::indexSequence_t;
		using substrate::internal::makeIndexSequence;

		template<typename... options_t, size_t... indices> constexpr static inline
			std::array<const optionsItem_t, sizeof...(options_t)>
				optionTupleToArray(const std::tuple<options_t...> &tuple, indexSequence_t<indices...>)
			{ return {{std::get<indices>(tuple)...}}; }

		template<typename... options_t> constexpr static inline auto
			optionToTuple(const std::tuple<options_t...> &tuple) { return tuple; }
		constexpr static inline std::tuple<option_t> optionToTuple(const option_t &option) { return {option}; }
		constexpr static inline std::tuple<optionSet_t> optionToTuple(const optionSet_t &optionSet)
			{ return {optionSet}; }

		template<typename... results_t, typename option_t, typename... options_t> constexpr static inline auto
			buildOptionsTuple(const std::tuple<results_t...> &results, option_t &&option, options_t &&...options) noexcept
		{
			const auto result{std::tuple_cat(results, optionToTuple(std::forward<option_t>(option)))};
			if constexpr (sizeof...(options_t) == 0)
				return result;
			else
				return buildOptionsTuple(result, std::forward<options_t>(options)...);
		}

		template<typename... options_t> constexpr static inline auto buildOptions(options_t &&...options) noexcept
			{ return buildOptionsTuple(std::tuple<>{}, std::forward<options_t>(options)...); }

		template<size_t offset, typename... options_t>
			constexpr optionsItem_t optionAt(const size_t index, const std::tuple<options_t...> &tuple)
		{
			if constexpr (offset + 1U == sizeof...(options_t))
				throw std::out_of_range{"index into options out of range"};
			else if (index == offset)
				return std::get<offset>(tuple);
			else
				return optionAt<offset + 1U>(index, tuple);
		}

		template<typename... options_t> struct optionsStorage_t final
		{
		private:
			std::tuple<options_t...> _options;

		public:
			constexpr optionsStorage_t(const std::tuple<options_t...> &options) noexcept : _options{options} { }
			constexpr optionsItem_t operator [](const size_t index)
				{ return optionAt<0U>(index, _options); }
			constexpr auto &options() const noexcept { return _options; }
		};

		template<typename... options_t> optionsStorage_t(const std::tuple<options_t...> &) ->
			optionsStorage_t<options_t...>;
	} // namespace internal

	template<typename... options_t> constexpr static inline auto
		options(options_t &&...options) noexcept
			{ return internal::buildOptions(std::forward<options_t>(options)...); }

	template<typename... options_t> constexpr static inline auto
		optionsArray(const std::tuple<options_t...> &tuple)
			{ return internal::optionTupleToArray(tuple, internal::makeIndexSequence<sizeof...(options_t)>{}); }

	// Represents a specific alternation in an optionSet_t
	struct SUBSTRATE_CLS_API optionAlternation_t final
	{
	private:
		std::string_view _value;
		std::string_view _help{};
		options_t _suboptions{};

	public:
		constexpr optionAlternation_t(const std::string_view &value, const std::string_view &help) noexcept :
			_value{value}, _help{help} { }
		template<size_t N> constexpr optionAlternation_t(const std::string_view &value, const std::string_view &help,
			const std::array<const internal::optionsItem_t, N> &suboptions) noexcept : _value{value}, _help{help},
				_suboptions{suboptions} { }
		constexpr optionAlternation_t(const optionAlternation_t &) noexcept = default;
		constexpr optionAlternation_t(optionAlternation_t &&) noexcept = default;

		constexpr optionAlternation_t &operator =(const optionAlternation_t &) noexcept = default;
		constexpr optionAlternation_t &operator =(optionAlternation_t &&) noexcept = default;

		[[nodiscard]] bool matches(const std::string_view &argument) const noexcept;
		[[nodiscard]] constexpr auto &suboptions() const noexcept { return _suboptions; }
	};
} // namespace substrate::commandLine

#endif /* SUBSTRATE_COMMAND_LINE_OPTIONS */
/* vim: set ft=cpp ts=4 sw=4 noexpandtab: */
