// SPDX-License-Identifier: BSD-3-Clause
#ifndef SUBSTRATE_COMMAND_LINE_OPTIONS
#define SUBSTRATE_COMMAND_LINE_OPTIONS

#include <cstddef>
#include <cassert>
#include <vector>
#include <variant>
#include <any>
#include <optional>
#include <string_view>
#include <functional>
#include <type_traits>
#include <substrate/static_vector>
#include <substrate/index_sequence>
#include <substrate/flags>
#include <substrate/utility>

namespace substrate::commandLine
{
	enum class optionFlags_t
	{
		repeatable,
		takesParameter
	};

	enum class optionValueType_t
	{
		signedInt,
		unsignedInt,
		boolean,
		string,
		path,
		userDefined,
	};

	struct optionFlagPair_t final
	{
		std::string_view _shortFlag{};
		std::string_view _longFlag{};
	};

	struct optionValue_t final { };
	struct optionAlternation_t;

	struct optionSignedInt_t final
	{
		int64_t min{INT64_MIN};
		int64_t max{INT64_MAX};
	};

	struct optionUnsignedInt_t final
	{
		uint64_t min{0U};
		uint64_t max{UINT64_MAX};
	};

	using optionValueParser_t = std::optional<std::any> (*)(const std::string_view &) noexcept;

	// A singular command line option such as a simple flag
	struct SUBSTRATE_CLS_API option_t final
	{
	private:
		using optionHolder_t = std::variant<std::string_view, optionFlagPair_t, std::monostate>;
		using flagsHolder_t = bitFlags_t<uint8_t, optionFlags_t>;

		optionHolder_t _option;
		std::string_view _help;
		flagsHolder_t _flags{};
		optionValueType_t _valueType{optionValueType_t::string};
		std::variant<std::monostate, optionSignedInt_t, optionUnsignedInt_t> _valueAllowedRange{};
		optionValueParser_t _valueParserFn{nullptr};

	public:
		constexpr option_t(const optionHolder_t &option, const std::string_view &help) noexcept :
			_option{option}, _help{help} { }
		constexpr option_t(const optionValue_t &, const std::string_view &help) noexcept :
			_option{std::monostate{}}, _help{help}, _flags{optionFlags_t::takesParameter} { }
		constexpr option_t(const option_t &) noexcept = default;
		constexpr option_t(option_t &&) noexcept = delete;

		constexpr option_t &operator =(const option_t &) noexcept = default;
		constexpr option_t &operator =(option_t &&) noexcept = delete;

		[[nodiscard]] constexpr option_t &valueType(const optionValueType_t type = optionValueType_t::string,
			const optionValueParser_t valueParserFn = nullptr) noexcept
		{
			_valueType = type;
			if (type == optionValueType_t::userDefined)
			{
				// A user-defined option must supply a parsing function to use
				assert(valueParserFn != nullptr);
				_valueParserFn = valueParserFn;
			}
			return *this;
		}

		[[nodiscard]] constexpr option_t &takesParameter(const optionValueType_t type = optionValueType_t::string,
			const optionValueParser_t valueParserFn = nullptr) noexcept
		{
			_flags.set(optionFlags_t::takesParameter);
			return valueType(type, valueParserFn);
		}

		[[nodiscard]] constexpr option_t &repeatable() noexcept
		{
			_flags.set(optionFlags_t::repeatable);
			return *this;
		}

		template<typename T> [[nodiscard]] constexpr option_t &valueRange(T min, T max) noexcept
		{
			if (_valueType == optionValueType_t::signedInt)
				_valueAllowedRange = optionSignedInt_t{min, max};
			else if (_valueType == optionValueType_t::unsignedInt)
				_valueAllowedRange = optionUnsignedInt_t{min, max};
			return *this;
		}

		[[nodiscard]] bool matches(const std::string_view &argument) const noexcept;
		[[nodiscard]] std::optional<std::any> parseValue(const std::string_view &value) const noexcept;

		[[nodiscard]] constexpr bool takesParameter() const noexcept
			{ return _flags.includes(optionFlags_t::takesParameter); }
		[[nodiscard]] constexpr bool isRepeatable() const noexcept
			{ return _flags.includes(optionFlags_t::repeatable); }
		[[nodiscard]] constexpr bool valueOnly() const noexcept
			{ return std::holds_alternative<std::monostate>(_option); }

		[[nodiscard]] constexpr auto &helpText() const noexcept { return _help; }

	private:
		[[nodiscard]] std::optional<std::any> parseSignedValue(const std::string_view &value) const noexcept;
		[[nodiscard]] std::optional<std::any> parseUnsignedValue(const std::string_view &value) const noexcept;
		[[nodiscard]] static std::optional<std::any> parseBoolValue(const std::string_view &value) noexcept;
		[[nodiscard]] static std::optional<std::any> parsePathValue(const std::string_view &value) noexcept;
	};

	// A set of command line option alternations such as a set of commands
	struct SUBSTRATE_CLS_API optionSet_t final
	{
	private:
		staticVector_t<const optionAlternation_t> _alternations;

	public:
		constexpr optionSet_t(const staticVector_t<const optionAlternation_t> &alternations) :
			_alternations{alternations} { }
		constexpr optionSet_t(const optionSet_t &) noexcept = default;
		constexpr optionSet_t(optionSet_t &&) noexcept = delete;

		constexpr optionSet_t &operator =(const optionSet_t &) noexcept = default;
		constexpr optionSet_t &operator =(optionSet_t &&) noexcept = delete;

		[[nodiscard]] std::optional<std::reference_wrapper<const optionAlternation_t>>
			matches(const std::string_view &argument) const noexcept;
	};

	template<size_t N> constexpr static inline staticVector_t<const optionAlternation_t>
		optionAlternations(optionAlternation_t (&&alternations)[N]) noexcept
			{ return {alternations, N}; }

	// The base container for a program's command line options
	struct options_t final
	{
	private:
		using item_t = std::variant<option_t, optionSet_t>;
		staticVector_t<const item_t> _options{};

		template<size_t N> constexpr static inline staticVector_t<const item_t>
			buildOptions(item_t (&&options)[N]) noexcept
				{ return {options, N}; }

	public:
		constexpr options_t() noexcept = default;
		constexpr options_t(const options_t &) noexcept = default;
		constexpr options_t(options_t &&) noexcept = delete;

		template<typename... Options, typename = std::enable_if_t<sizeof...(Options) != 0>>
			constexpr options_t(Options &&...options) noexcept :
				_options{buildOptions({std::forward<Options>(options)...})} { }

		constexpr options_t &operator =(const options_t &) noexcept = default;
		constexpr options_t &operator =(options_t &&) noexcept = delete;

		[[nodiscard]] constexpr auto begin() const noexcept { return _options.begin(); }
		[[nodiscard]] constexpr auto end() const noexcept { return _options.end(); }
	};

	// Represents a specific alternation in an optionSet_t
	struct SUBSTRATE_CLS_API optionAlternation_t final
	{
	private:
		std::string_view _value;
		std::string_view _help{};
		options_t _suboptions{};

	public:
		constexpr optionAlternation_t(const std::string_view &value, const std::string_view &help) noexcept :
			_value{value}, _help{help} { }
		constexpr optionAlternation_t(const std::string_view &value, const std::string_view &help,
			const options_t &suboptions) noexcept : _value{value}, _help{help}, _suboptions{suboptions} { }
		constexpr optionAlternation_t(const optionAlternation_t &) noexcept = default;
		constexpr optionAlternation_t(optionAlternation_t &&) noexcept = delete;

		constexpr optionAlternation_t &operator =(const optionAlternation_t &) noexcept = default;
		constexpr optionAlternation_t &operator =(optionAlternation_t &&) noexcept = delete;

		[[nodiscard]] bool matches(const std::string_view &argument) const noexcept;
		[[nodiscard]] constexpr auto &suboptions() const noexcept { return _suboptions; }
	};
} // namespace substrate::commandLine

#endif /* SUBSTRATE_COMMAND_LINE_OPTIONS */
/* vim: set ft=cpp ts=4 sw=4 noexpandtab: */
