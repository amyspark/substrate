// SPDX-License-Identifier: BSD-3-Clause
#ifndef SUBSTRATE_MMAP
#define SUBSTRATE_MMAP
#ifdef _WINDOWS
#	error "mmap is a *nix only header"
#endif

#include <cstdint>
#include <unistd.h>
#include <sys/mman.h>
#include <stdexcept>

#include <substrate/internal/defs>

namespace substrate
{
	struct mmap_t final
	{
	private:
		int32_t _fd;
		off_t _len;
		void *_addr;

		mmap_t(const mmap_t &map, const off_t len, const int32_t prot, const int32_t flags = MAP_SHARED,
			void *addr = nullptr) noexcept : _fd{-1}, _len{len}, _addr{[&]() noexcept -> void *
			{
				const auto ptr = ::mmap(addr, len, prot, flags, map._fd, 0);
				return ptr == MAP_FAILED ? nullptr : ptr;
			}()} { }

		template<typename T> T *index(const off_t idx) const
		{
			if (idx < _len)
			{
				const auto addr = reinterpret_cast<std::uintptr_t>(_addr);
				return reinterpret_cast<T *>(addr + idx);
			}
			throw std::out_of_range("mmap_t index out of range");
		}

	public:
		constexpr mmap_t() noexcept : _fd{-1}, _len{0}, _addr{nullptr} { }
		mmap_t(const int32_t fd, const off_t len, const int32_t prot, const int32_t flags = MAP_SHARED,
			void *addr = nullptr) noexcept : _fd{fd}, _len{len}, _addr{[&]() noexcept -> void *
			{
				const auto ptr = ::mmap(addr, len, prot, flags, fd, 0);
				return ptr == MAP_FAILED ? nullptr : ptr;
			}()} { }
		mmap_t(mmap_t &&map) noexcept : mmap_t{} { swap(map); }
		void operator =(mmap_t &&map) noexcept { swap(map); }

		~mmap_t() noexcept
		{
			if (_fd != -1)
				::close(_fd);
			if (_addr)
				::munmap(_addr, _len);
		}

		SUBSTRATE_NO_DISCARD(bool valid() const noexcept) { return _addr; }

		void swap(mmap_t &map) noexcept
		{
			std::swap(_fd, map._fd);
			std::swap(_addr, map._addr);
			std::swap(_len, map._len);
		}

		SUBSTRATE_NO_DISCARD(mmap_t dup(const int32_t prot, const off_t len, const int32_t flags,
			void *addr) const noexcept)
		{
			if (!valid())
				return {};
			return {*this, len, prot, flags, addr};
		}

		template<typename T> T *address() noexcept { return static_cast<T *>(_addr); }
		template<typename T> const T *address() const noexcept { return static_cast<const T *>(_addr); }
		SUBSTRATE_NO_DISCARD(off_t length() const noexcept) { return _len; }
		template<typename T> T *operator [](const off_t idx) { return index<T>(idx); }
		template<typename T> const T *operator [](const off_t idx) const { return index<const T>(idx); }
		template<typename T> T *at(const off_t idx) { return index<T>(idx); }
		template<typename T> const T *at(const off_t idx) const { return index<const T>(idx); }

		void *address(const off_t offset) noexcept { return index<void *>(offset); }
		const void *address(const off_t offset) const noexcept { return index<const void *>(offset); }

		template<typename T> void copyTo(const off_t idx, T &value) const
		{
			const auto src = index<const void *>(idx);
			memcpy(&value, src, sizeof(T));
		}

		template<typename T> void copyFrom(const off_t idx, const T &value) const
		{
			const auto dest = index<void *>(idx);
			memcpy(dest, &value, sizeof(T));
		}

		bool operator ==(const mmap_t &b) const noexcept
			{ return _fd == b._fd && _addr == b._addr && _len == b._len; }
		bool operator !=(const mmap_t &b) const noexcept { return !(*this == b); }
	};

	inline void swap(mmap_t &a, mmap_t &b) noexcept { a.swap(b); }
}


#endif /* SUBSTRATE_MMAP */
/* vim: set ft=cpp ts=4 sw=4 noexpandtab: */
